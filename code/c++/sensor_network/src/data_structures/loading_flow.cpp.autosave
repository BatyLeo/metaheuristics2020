#include "loading_flow.h"

Arc::Arc(Node* origin_node, Node* destination_node, int free_space_lower_bound, int free_space_upper_bound) :
origin_node(origin_node), destination_node(destination_node), free_space_lower_bound(free_space_lower_bound), free_space_upper_bound(free_space_upper_bound)
{

}

Node::Node(int size) : 
size(size), shortest_path_from_sink(-1), shortest_path_from_source(-1)
{
    
}

LoadingFlow::LoadingFlow(const Solution* solution, bool vertical){
    // !!! the solution must be packed to bottom (resp. left)
    const DataSet* data_set = solution->getDataSet();

    int number_boxes = data_set->getNumberBoxes();

    box_nodes = vector<Node*>(number_boxes, nullptr);
    arcs = vector<vector<Arc*> >(number_boxes, vector<Arc*>(number_boxes, nullptr));
    
    source_node = new Node(0);
    sink_node = new Node(0);
    
    for(int index = 0; index<number_boxes; index++){
        int node_weight = data_set->getBoxWidth(index);
        if(vertical){
            node_weight = data_set->getBoxHeight(index);
        }
        box_nodes[index] = new Node(node_weight);
    }

}

LoadingFlow::~LoadingFlow(){
    delete source_node;
    delete sink_node;

    for(int index = 0; index<box_nodes.size(); index++){
        delete box_nodes[index];
    }

    for(int index_1 = 0; index_1<arcs.size(); index_1++){
        for(int index_2 = 0; index_2<arcs[index_1].size(); index_2++){
            delete arcs[index_1][index_2];
        }
    }
}
